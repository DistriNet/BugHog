<html>
    <head>
        
    </head>
    <body>
        
    </body>
<script>
    function getHash(arr) {
  let hash = 0;
  for (let i = 0; i < arr.length; ++i) {
    hash += Math.abs(arr[i]);
  }
  return hash;
}

function getStandardFingerprintJsHash() {
  // https://github.com/fingerprintjs/fingerprintjs/blob/master/src/sources/audio.ts#L56
  const hashFromIndex = 4500;
  const hashToIndex = 5000;
  const AudioContext =
    window.OfflineAudioContext || window.webkitOfflineAudioContext;
  const context = new AudioContext(1, hashToIndex, 44100);

  const oscillator = context.createOscillator();
  oscillator.type = "triangle";
  oscillator.frequency.value = 10000;

  const compressor = context.createDynamicsCompressor();
  compressor.threshold.value = -50;
  compressor.knee.value = 40;
  compressor.ratio.value = 12;
  compressor.attack.value = 0;
  compressor.release.value = 0.25;

  oscillator.connect(compressor);
  compressor.connect(context.destination);
  oscillator.start(0);

  return context.startRendering().then((buffer) => {
    const sampleRange = buffer.getChannelData(0).subarray(hashFromIndex);
    return getHash(sampleRange);
  });
}

function getBiquadFingerprintJsHash() {
  // https://github.com/fingerprintjs/fingerprintjs/blob/0b398a9c2ce056c472be1e9a35d5884fda52a60f/src/sources/audio.ts#L116
  const targetSampleIndex = 3395;
  const AudioContext =
    window.OfflineAudioContext || window.webkitOfflineAudioContext;
  const context = new AudioContext(1, targetSampleIndex + 1, 44100);

  const oscillator = context.createOscillator();
  oscillator.type = "square";
  oscillator.frequency.value = 1000;

  const compressor = context.createDynamicsCompressor();
  compressor.threshold.value = -70;
  compressor.knee.value = 40;
  compressor.ratio.value = 12;
  compressor.attack.value = 0;
  compressor.release.value = 0.25;

  const filter = context.createBiquadFilter();
  filter.type = "allpass";
  filter.frequency.value = 5.239622852977861;
  filter.Q.value = 0.1;

  oscillator.connect(compressor);
  compressor.connect(filter);
  filter.connect(context.destination);
  oscillator.start(0);

  return context.startRendering().then((buffer) => {
    const signal = buffer.getChannelData(0);
    return signal[signal.length - 1];
  });
}

function getAnalyserNodeHashes() {
  // Seen in various gists, e.g. https://gist.github.com/shermozle/7a7c664df3c7369cf064a27479d7145c#file-f4e48049-js-L3086
  return new Promise((resolve, reject) => {
    const AudioContext =
      window.OfflineAudioContext || window.webkitOfflineAudioContext;
    const context = new AudioContext(1, 5000, 44100);
    const oscillator = context.createOscillator();
    oscillator.type = "triangle";

    const analyser = context.createAnalyser();

    const gain = context.createGain();
    gain.gain.value = 0;

    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);

    const compressor = context.createDynamicsCompressor();
    compressor.threshold.value = -50;
    compressor.knee.value = 40;
    compressor.ratio.value = 12;
    compressor.attack.value = 0;
    compressor.release.value = 0.25;

    oscillator.connect(compressor);
    compressor.connect(analyser);
    analyser.connect(scriptProcessor);
    scriptProcessor.connect(gain);
    gain.connect(context.destination);

    scriptProcessor.onaudioprocess = function () {
      const floatFrequencies = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(floatFrequencies);

      const byteFrequencies = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(byteFrequencies);

      const floatTimeSamples = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(floatTimeSamples);

      const byteTimeSamples = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(byteTimeSamples);

      resolve({
        floatfreq: JSON.stringify(floatFrequencies.slice(0, 30)),
        bytefreq: JSON.stringify(byteFrequencies.slice(0, 30)),
        floattime: JSON.stringify(floatTimeSamples.slice(0, 500)),
        bytetime: JSON.stringify(byteTimeSamples.slice(0, 500)),
      });
    };

    oscillator.start(0);
    context.startRendering();
  });

  // TODO:
  // AnalyserNode.getByteTimeDomainData
  // AnalyserNode.getFloatTimeDomainData
  // Examples:
  // https://gist.github.com/shermozle/7a7c664df3c7369cf064a27479d7145c
  // https://gist.github.com/PavMel/8e25addf708db0c624d798830b930da0
}

function submit() {
  Promise.all([
    getStandardFingerprintJsHash(),
    getBiquadFingerprintJsHash(),
  ]).then((hashes) => {
    const fingerprintData = `${hashes[0]}|${hashes[1]}`;

    console.log(fingerprintData);
    var img = document.createElement("img");
    document.body.appendChild(img);
    img.src = "/report/?bughog_output=" + encodeURIComponent(fingerprintData);
  });
}

submit();
</script>
</html>